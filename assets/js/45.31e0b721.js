(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{370:function(n,a,e){"use strict";e.r(a);var s=e(0),t=Object(s.a)({},(function(){var n=this,a=n._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h3",{attrs:{id:"javascript对象继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#javascript对象继承"}},[n._v("#")]),n._v(" JavaScript对象继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  \n  // 父类方法\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\n\n// 子类\nclass Dog extends Animal {\n  constructor(name, breed) {\n    super(name);\n    this.breed = breed;\n  }\n  \n  // 子类方法\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\n\n// 创建对象\nconst animal = new Animal('Animal');\nconst dog = new Dog('Dog', 'German Shepherd');\n\nanimal.speak();  // Output: Animal makes a noise.\ndog.speak();  // Output: Dog barks.\n")])])]),a("p",[n._v("以上代码实现了JavaScript对象继承的功能。")]),n._v(" "),a("p",[n._v("首先定义了一个父类Animal，构造函数中接收一个name参数，并将其赋值给实例的name属性。类中还包含一个speak方法，用于输出动物的叫声。\n然后定义了一个子类Dog，继承自Animal。子类的构造函数接收两个参数name和breed，其中name作为父类构造函数的参数传递，breed则是子类特有的属性。子类中重写了speak方法，用于输出狗的叫声。\n最后，创建了一个父类对象animal和一个子类对象dog，分别调用它们的speak方法进行输出。")]),n._v(" "),a("p",[n._v("以上代码中使用了ES6的class语法来定义类，并使用了extends关键字来实现继承。父类的构造函数中使用super关键字来调用父类的构造函数。子类中重写了父类的方法，即实现了方法的覆盖。")])])}),[],!1,null,null,null);a.default=t.exports}}]);